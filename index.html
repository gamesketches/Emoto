<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Emoto</title>
    <script type="text/javascript" src="phaser.min.js"></script>
</head>
<body>
  <script>
    // getUserMedia only works over https in Chrome 47+, so we redirect to https. Also notify user if running from file.
    if (window.location.protocol == "file:") {
      alert("You seem to be running this example directly from a file. Note that these examples only work when served from a server or localhost due to canvas cross-domain restrictions.");
    } else if (window.location.hostname !== "localhost" && window.location.protocol !== "https:"){
      window.location.protocol = "https";
    }
  </script>
  <script src="clmStuff/js/utils.js"></script>
  <script src="clmStuff/js/clmtrackr.js"></script>
  <script src="clmStuff/models/model_pca_20_svm_emotionDetection.js"></script>
  <script src="clmStuff/js/Stats.js"></script>
  <script src="clmStuff/examples/js/emotion_classifier.js"></script>
  <script src="clmStuff/examples/js/emotionmodel.js"></script>
  <video id="videoel" width="400" height="300" preload="auto" loop>
  </video>
  <script type="text/javascript">
  var game = new Phaser.Game(800, 400, Phaser.AUTO, '',
        {preload: preload, create: create, update: update});

  var maxVelocity = 700;
  var check, platforms, ctrack, classifier;
  var p1Ball;
  var vid = document.getElementById('videoel');
  function preload() {
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
    window.URL = window.URL || window.webkitURL || window.msURL || window.mozURL;

    // check for camerasupport
    if (navigator.getUserMedia) {
      // set up stream

      var videoSelector = {video : true};
      if (window.navigator.appVersion.match(/Chrome\/(.*?) /)) {
        var chromeVersion = parseInt(window.navigator.appVersion.match(/Chrome\/(\d+)\./)[1], 10);
        if (chromeVersion < 20) {
          videoSelector = "video";
        }
      };

      navigator.getUserMedia(videoSelector, function( stream ) {
        if (vid.mozCaptureStream) {
          vid.mozSrcObject = stream;
        } else {
          vid.src = (window.URL && window.URL.createObjectURL(stream)) || stream;
        }
      }, function() {
        //insertAltVideo(vid);
        alert("There was some problem trying to fetch video from your webcam. If you have a webcam, please make sure to accept when the browser asks for access to your webcam.");
      });
    } else {
      //insertAltVideo(vid);
      alert("This demo depends on getUserMedia, which your browser does not seem to support. :(");
    }

    /*********** setup of emotion detection *************/

    ctrack = new clm.tracker({useWebGL : true});
    ctrack.init(pModel);
    ctrack.start(vid);
    game.load.image("sadBall", "blue.png");
    game.load.image("angryBall", "red.png");
    game.load.image("brick", "brick.png");
  }

  function create() {

    game.physics.startSystem(Phaser.Physics.ARCADE);

    p1Ball = game.add.sprite(40, 200, 'sadBall');
    p1Ball.anchor.setTo(.5,.5);
    game.physics.enable(p1Ball);
    p1Ball.checkWorldBounds = true;
    p1Ball.body.collideWorldBounds = true;
    p1Ball.body.immovable = true;
    p1Ball.body.bounce.set(1);

    p2Ball = game.add.sprite(400, 200, 'sadBall');
    p2Ball.anchor.setTo(.5,.5);
    game.physics.enable(p2Ball);
    p2Ball.checkWorldBounds = true;
    p2Ball.body.collideWorldBounds = true;
    p2Ball.body.immovable = true;
    p2Ball.body.bounce.set(1);

    platforms = game.add.group();
    platforms.enableBody = true;
    platforms.physicsBodyType = Phaser.Physics.ARCADE;
    platforms.create(300, 300, 'brick');

    var vertBoundaries = game.make.bitmapData(800, 10);
    vertBoundaries.ctx.fillStyle = "#ff0000";
    vertBoundaries.ctx.fillRect(0, 0, 800, 10);

    //var bottom = platforms.preload(0, 390, vertBoundaries, 0);
    //bottom.body.immovable = true;

  	vid.play();
    classifier = new emotionClassifier();
    classifier.init(emotionModel);
    game.physics.arcade.velocityFromAngle(45, 500, p1Ball.body.velocity);
    game.physics.arcade.velocityFromAngle(45,-500, p2Ball.body.velocity);
  }

  function update() {
    var cp = ctrack.getCurrentParameters();
    var er = classifier.meanPredict(cp);
    function modifyVelocity(vector, result) {
      var modifierValue = result[0].value > result[1].value ? result[0].value * 10 : result[1].value * -10;
      if(vector > 0) {
          return vector + modifierValue;
      }
      else{
          return vector - modifierValue;
      }
    }
    if(er) {
      p1Ball.body.velocity.x = modifyVelocity(p1Ball.body.velocity.x, er);
      p1Ball.body.velocity.y = modifyVelocity(p1Ball.body.velocity.y, er);
      if(er[0].value > er[1].value) {
          p1Ball.loadTexture('angryBall');
      }
      else {
          p1Ball.loadTexture('sadBall');
      }
    }
    function FlipDirection(p1Ball, p2Ball){
        p1Ball.body.velocity.x *= -1;
        p2Ball.body.velocity.x *= -1;
        p1Ball.body.velocity.y *= -1;
        p2Ball.body.velocity.y *= -1;
    }
    game.physics.arcade.collide(p1Ball, platforms, function(ball, brick) { brick.kill()}, function(ball, brick) { return true}, this);
    if(game.physics.arcade.overlap(p1Ball, p2Ball)) {
        FlipDirection(p1Ball, p2Ball);
    }
  /*  if(Phaser.Rectangle.intersects(white, passing)){
      game.state.add('gameOver', {
      			preload: function() {},
      			create: function (){
      							game.add.text(400, 300, 'Check your privilege', { fontSize: '32px', fill: '#FFF' });
                  },
      			update: function() {}
      		});
      game.state.start('gameOver');

    }
    */

  }
</script>
</body>
</html>
